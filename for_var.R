# run command line
# VAR model forecast
for_var <-
  function(mts_object,
           # this is an mts object includes all the time series of endo and exo variables
           endo_v,
           # endogeneous variables
           exo_v,
           # exogeneous variables
           b_year,
           # beginning year of historical period
           b_month,
           # beginning month of historical period
           e_year,
           # end year of historical period
           e_month,
           # end month of historical period
           logged_v,
           # a vector of logged = TRUE or FALSE for endo_v and exo_v, if not sure, put in NA so that logged can be generated by automated test
           ns_v,
           # a vector of seasonal difference, if not sure, put in NA so that ns can be generated by automated test
           nd_v,
           # a vector of first difference, if not sure, put in NA so that nd can be generated by automated test
           var_params = list(lag = 1,
                             type = c('none'),
                             ahead = 12)#,# parameters put into var model 
  ){
    require(lmtest)
    require(tseries)
    require(vars)
    require(lubridate)
    require(forecast)
    # mts_object <- my_mts
    # b_year <- 2000
    # b_month <- 1
    # e_year <- 2015
    # e_month <- 12
    # endo_v <- c('hus_sfhs_nar','us_starts','hus_sfhp_nar')
    # exo_v <- c('us_gdp','us_population','us_unmr','us_med_hh_inc', 'us_interest_rate')
    # var_params <- 
    if(!missing(exo_v)){
      var_v <- c(endo_v,exo_v)
    } else {
      var_v <- endo_v
    }
    #var_params = list(lag = 1,type = c('none'),ahead = 12)
    # sub matrix by endo_v,exo_v,
    if (missing(logged_v)) {
      logged_v <- rep(NA, length(var_v))
    }
    if (missing(ns_v)) {
      ns_v <- rep(NA, length(var_v))
    }
    if (missing(nd_v)) {
      nd_v <- rep(NA, length(var_v))
    }
    stopifnot(
      length(logged_v) == length(var_v),
      length(ns_v) == length(var_v),
      length(nd_v) == length(var_v)
    )
    # subset matrix to include only endo_v and exo_v, from start date
    sub_matrix <- window(mts_object[,var_v],
                         start = c(b_year, b_month))
    
    #don't use end date     #end = c(e_year,e_month))
    # run differencing function on each variable
    diff_ls <-
      lapply(1:length(var_v), function(i)
        log_diff_f(
          sub_matrix[, i],
          logged = logged_v[i],
          ns = ns_v[i],
          nd = nd_v[i]
        ))
    names(diff_ls) <- colnames(sub_matrix)
    # return the result of logged or differenced series (diff.xstar)
    diff.xstar <- lapply(diff_ls, function(x)
      x$xstar)
    diff_matrix <- cbts(diff.xstar)
    # combine nd,ns,logged into a list for query later
    diff.type <-
      lapply(diff_ls, function(x)
        data.frame(
          ns = x$ns,
          nd = x$nd,
          logged = x$logged
        ))
    # remove the NA values from the diff_matrix before the end date
    diff_no_na <-
      na.omit(window(diff_matrix, end = c(e_year, e_month)))
    # workaround on exogen matrix cannot be returned when using function
    # VAR model
    if (!missing(exo_v)){
      diff_exogen_mx <- diff_no_na[,exo_v]
      assign('diff_exogen_mx',diff_exogen_mx,envir = .GlobalEnv)
      var.model <-
        VAR(y = diff_no_na[, endo_v],
            p = var_params[['lag']],
            exogen = diff_exogen_mx,
            type = var_params[['type']])
      
    } else{
      var.model <-
        VAR(y = diff_no_na[, endo_v],
            p = var_params[['lag']],
            type = var_params[['type']])
    }
    
    # use months.plus function to find the end date of prediction period
    ahead <- var_params[['ahead']]
    month_plus_1 <-
      months.plus(y = e_year, m = e_month, p = 1)
    month_plus_ahead <-
      months.plus(y = e_year, m = e_month, p = ahead)
    # var.predict is a list of data frames (forecast,upper,lower,confidence interval)
    if(!missing(exo_v)){
      var.predict <- predict(
        object = var.model,
        n.ahead = ahead,
        dumvar = window(
          diff_matrix[, exo_v],
          start = c(month_plus_1[['year']], month_plus_1[['month']]),
          end = c(month_plus_ahead[['year']], month_plus_ahead[['month']]),
          frequency = frequency(diff_matrix)
        ),
        ci = 0.95
      )$fcst
      
    } else {
      var.predict <- predict(
        object = var.model,
        n.ahead = ahead,
        ci = 0.95
      )$fcst
    }
    
    var.predict.ts <-
      lapply(var.predict, function(x)
        ts(
          x[, 'fcst'],
          start = c(month_plus_1[['year']], month_plus_1[['month']]),
          end = c(month_plus_ahead[['year']], month_plus_ahead[['month']]),
          frequency = 12
        ))
    # convert the list of ts object into mts object
    var.predict.mts <- cbts(var.predict.ts)
    # rbind the diff_matrix with endo_v only, with the predicted value
    cb.diff.mts <-
      ts(
        rbind(window(
          diff_matrix[, endo_v], end = c(e_year, e_month)
        ), var.predict.mts),
        start = start(diff_matrix),
        end = end(var.predict.mts),
        frequency = 12
      )
    # apply reverse differencing function to convert the series back to original data format
    out.ls <- lapply(endo_v, function(var) {
      logged <- diff.type[[var]]$logged
      nd <- diff.type[[var]]$nd
      ns <- diff.type[[var]]$ns
      r.series <-
        reverse_diff(
          cb.diff.mts,
          var,
          logged = logged,
          nd = nd,
          ns = ns,
          xi.ls = diff_ls
        )
      r.series
    })
    names(out.ls) <- endo_v
    # cbind ts list to mts
    out.mts <- cbts(out.ls)
    out.mts
  }

#
